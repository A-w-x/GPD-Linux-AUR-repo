From c951bfcfc4e73f94caf44c53307cb1a2a15ec86a Mon Sep 17 00:00:00 2001
From: gituser <nore@nop.np>
Date: Mon, 18 Apr 2022 15:48:37 +0200
Subject: [PATCH 6/7] Revert "anv: fix dynamic state emission"

This reverts commit f348103fce4484b891a58bf3147b71e3a3558135.
---
 src/intel/vulkan/anv_private.h     | 25 --------
 src/intel/vulkan/genX_cmd_buffer.c | 27 ++++----
 src/intel/vulkan/gfx7_cmd_buffer.c | 68 ++++++++++----------
 src/intel/vulkan/gfx8_cmd_buffer.c | 99 ++++++++++++++----------------
 4 files changed, 93 insertions(+), 126 deletions(-)

diff --git a/src/intel/vulkan/anv_private.h b/src/intel/vulkan/anv_private.h
index eeb0e4a05f5..abac1d9deb6 100644
--- a/src/intel/vulkan/anv_private.h
+++ b/src/intel/vulkan/anv_private.h
@@ -3543,31 +3543,6 @@ anv_pipeline_get_last_vue_prog_data(const struct anv_graphics_pipeline *pipeline
       return &get_vs_prog_data(pipeline)->base;
 }
 
-static inline bool
-anv_cmd_buffer_needs_dynamic_state(const struct anv_cmd_buffer *cmd_buffer,
-                                   anv_cmd_dirty_mask_t mask)
-{
-   /* Only dynamic state */
-   assert((mask & ANV_CMD_DIRTY_PIPELINE) == 0);
-
-   /* If all the state is statically put into the pipeline batch, nothing to
-    * do.
-    */
-   if ((cmd_buffer->state.gfx.pipeline->static_state_mask & mask) == mask)
-      return false;
-
-   /* Dynamic state affected by vkCmd* commands */
-   if (cmd_buffer->state.gfx.dirty & mask)
-      return true;
-
-   /* For all other states we might have part of the information in the
-    * anv_graphics_pipeline::dynamic_state not emitted as part of the pipeline
-    * batch so we need to reemit the packet associated with this state if the
-    * pipeline changed.
-    */
-   return (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_PIPELINE) != 0;
-}
-
 VkResult
 anv_device_init_rt_shaders(struct anv_device *device);
 
diff --git a/src/intel/vulkan/genX_cmd_buffer.c b/src/intel/vulkan/genX_cmd_buffer.c
index 0379ba8ad0c..0ec6c7eb752 100644
--- a/src/intel/vulkan/genX_cmd_buffer.c
+++ b/src/intel/vulkan/genX_cmd_buffer.c
@@ -3963,6 +3963,11 @@ genX(cmd_buffer_flush_state)(struct anv_cmd_buffer *cmd_buffer)
    if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_PIPELINE) {
       anv_batch_emit_batch(&cmd_buffer->batch, &pipeline->base.batch);
 
+      /* Remove from dynamic state emission all of stuff that is baked into
+       * the pipeline.
+       */
+      cmd_buffer->state.gfx.dirty &= ~pipeline->static_state_mask;
+
       /* If the pipeline changed, we may need to re-allocate push constant
        * space in the URB.
        */
@@ -4036,23 +4041,23 @@ genX(cmd_buffer_flush_state)(struct anv_cmd_buffer *cmd_buffer)
 
    cmd_buffer_emit_clip(cmd_buffer);
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE))
-      cmd_buffer_emit_streamout(cmd_buffer);
+   if (pipeline->dynamic_states & ANV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE) {
+      if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE | ANV_CMD_DIRTY_XFB_ENABLE))
+         cmd_buffer_emit_streamout(cmd_buffer);
+   }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_SCISSOR |
-                                          ANV_CMD_DIRTY_RENDER_TARGETS |
-                                          ANV_CMD_DIRTY_DYNAMIC_VIEWPORT)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_DYNAMIC_SCISSOR |
+                                      ANV_CMD_DIRTY_RENDER_TARGETS |
+                                      ANV_CMD_DIRTY_DYNAMIC_VIEWPORT |
+                                      ANV_CMD_DIRTY_PIPELINE)) {
       cmd_buffer_emit_viewport(cmd_buffer);
       cmd_buffer_emit_depth_viewport(cmd_buffer,
                                      pipeline->depth_clamp_enable);
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_SCISSOR |
-                                          ANV_CMD_DIRTY_RENDER_TARGETS |
-                                          ANV_CMD_DIRTY_DYNAMIC_VIEWPORT))
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_DYNAMIC_SCISSOR |
+                                      ANV_CMD_DIRTY_RENDER_TARGETS |
+                                      ANV_CMD_DIRTY_DYNAMIC_VIEWPORT))
       cmd_buffer_emit_scissor(cmd_buffer);
 
    genX(cmd_buffer_flush_dynamic_state)(cmd_buffer);
diff --git a/src/intel/vulkan/gfx7_cmd_buffer.c b/src/intel/vulkan/gfx7_cmd_buffer.c
index 5060362878e..2d13f414693 100644
--- a/src/intel/vulkan/gfx7_cmd_buffer.c
+++ b/src/intel/vulkan/gfx7_cmd_buffer.c
@@ -110,8 +110,7 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
    struct anv_graphics_pipeline *pipeline = cmd_buffer->state.gfx.pipeline;
    struct anv_dynamic_state *d = &cmd_buffer->state.gfx.dynamic;
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY) {
       uint32_t topology;
       if (anv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_EVAL))
          topology = pipeline->topology;
@@ -121,21 +120,21 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       cmd_buffer->state.gfx.primitive_topology = topology;
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_RENDER_TARGETS |
-                                          ANV_CMD_DIRTY_DYNAMIC_LINE_WIDTH |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
-                                          ANV_CMD_DIRTY_DYNAMIC_CULL_MODE |
-                                          ANV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_RENDER_TARGETS |
+                                      ANV_CMD_DIRTY_DYNAMIC_LINE_WIDTH |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
+                                      ANV_CMD_DIRTY_DYNAMIC_CULL_MODE |
+                                      ANV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
       /* Take dynamic primitive topology in to account with
        *    3DSTATE_SF::MultisampleRasterizationMode
        */
       uint32_t ms_rast_mode = 0;
 
-      if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                             ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
+      if (cmd_buffer->state.gfx.pipeline->dynamic_states &
+          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY) {
          VkPrimitiveTopology primitive_topology =
             cmd_buffer->state.gfx.dynamic.primitive_topology;
 
@@ -167,9 +166,8 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       anv_batch_emit_merge(&cmd_buffer->batch, sf_dw, pipeline->gfx7.sf);
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_BLEND_CONSTANTS |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_REFERENCE)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_DYNAMIC_BLEND_CONSTANTS |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_REFERENCE)) {
       struct anv_state cc_state =
          anv_cmd_buffer_alloc_dynamic_state(cmd_buffer,
                                             GENX(COLOR_CALC_STATE_length) * 4,
@@ -189,8 +187,7 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       }
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_LINE_STIPPLE)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_LINE_STIPPLE) {
       anv_batch_emit(&cmd_buffer->batch, GENX(3DSTATE_LINE_STIPPLE), ls) {
          ls.LineStipplePattern = d->line_stipple.pattern;
          ls.LineStippleInverseRepeatCount =
@@ -199,15 +196,15 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       }
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_RENDER_TARGETS |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_COMPARE_MASK |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_WRITE_MASK |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_OP)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_RENDER_TARGETS |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_COMPARE_MASK |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_WRITE_MASK |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_OP)) {
       uint32_t depth_stencil_dw[GENX(DEPTH_STENCIL_STATE_length)];
 
       struct GENX(DEPTH_STENCIL_STATE) depth_stencil = {
@@ -248,9 +245,9 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
    }
 
    if (cmd_buffer->state.gfx.gfx7.index_buffer &&
-       anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_INDEX_BUFFER |
-                                          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE)) {
+       cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_INDEX_BUFFER |
+                                      ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE)) {
       struct anv_buffer *buffer = cmd_buffer->state.gfx.gfx7.index_buffer;
       uint32_t offset = cmd_buffer->state.gfx.gfx7.index_offset;
 
@@ -280,9 +277,8 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
     * threads or if we have dirty dynamic primitive topology state and
     * need to toggle 3DSTATE_WM::MultisampleRasterizationMode dynamically.
     */
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_STATE |
-                                          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_STATE ||
+       cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY) {
       const uint8_t color_writes = cmd_buffer->state.gfx.dynamic.color_writes;
 
       bool dirty_color_blend =
@@ -315,16 +311,14 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
 
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_SAMPLE_LOCATIONS)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_SAMPLE_LOCATIONS) {
       genX(emit_multisample)(&cmd_buffer->batch,
                              cmd_buffer->state.gfx.dynamic.sample_locations.samples,
                              cmd_buffer->state.gfx.dynamic.sample_locations.locations);
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_STATE |
-                                          ANV_CMD_DIRTY_DYNAMIC_LOGIC_OP)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_STATE ||
+       cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_LOGIC_OP) {
       const uint8_t color_writes = cmd_buffer->state.gfx.dynamic.color_writes;
       bool dirty_color_blend =
          cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_STATE;
diff --git a/src/intel/vulkan/gfx8_cmd_buffer.c b/src/intel/vulkan/gfx8_cmd_buffer.c
index 6c0fffe9fd1..272063b697b 100644
--- a/src/intel/vulkan/gfx8_cmd_buffer.c
+++ b/src/intel/vulkan/gfx8_cmd_buffer.c
@@ -323,15 +323,13 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
    struct anv_dynamic_state *d = &cmd_buffer->state.gfx.dynamic;
 
 #if GFX_VER >= 11
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_SHADING_RATE)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_SHADING_RATE) {
       genX(emit_shading_rate)(&cmd_buffer->batch, pipeline,
                               &cmd_buffer->state.gfx.dynamic);
    }
 #endif /* GFX_VER >= 11 */
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY) {
       uint32_t topology;
       if (anv_pipeline_has_stage(pipeline, MESA_SHADER_TESS_EVAL))
          topology = pipeline->topology;
@@ -345,8 +343,8 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       }
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_LINE_WIDTH)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_DYNAMIC_LINE_WIDTH)) {
       uint32_t sf_dw[GENX(3DSTATE_SF_length)];
       struct GENX(3DSTATE_SF) sf = {
          GENX(3DSTATE_SF_header),
@@ -364,12 +362,12 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       anv_batch_emit_merge(&cmd_buffer->batch, sf_dw, pipeline->gfx8.sf);
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
-                                          ANV_CMD_DIRTY_DYNAMIC_CULL_MODE |
-                                          ANV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS |
+                                      ANV_CMD_DIRTY_DYNAMIC_CULL_MODE |
+                                      ANV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_BIAS_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
       /* Take dynamic primitive topology in to account with
        *    3DSTATE_RASTER::APIMode
        *    3DSTATE_RASTER::DXMultisampleRasterizationEnable
@@ -379,8 +377,8 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       bool msaa_raster_enable = false;
       bool aa_enable = 0;
 
-      if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                             ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) {
+      if (cmd_buffer->state.gfx.pipeline->dynamic_states &
+          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY) {
          VkPrimitiveTopology primitive_topology =
             cmd_buffer->state.gfx.dynamic.primitive_topology;
 
@@ -423,9 +421,8 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
     * using a big old #if switch here.
     */
 #if GFX_VER == 8
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_BLEND_CONSTANTS |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_REFERENCE)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_DYNAMIC_BLEND_CONSTANTS |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_REFERENCE)) {
       struct anv_state cc_state =
          anv_cmd_buffer_alloc_dynamic_state(cmd_buffer,
                                             GENX(COLOR_CALC_STATE_length) * 4,
@@ -446,15 +443,15 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       }
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_RENDER_TARGETS |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_COMPARE_MASK |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_WRITE_MASK |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_OP)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_RENDER_TARGETS |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_COMPARE_MASK |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_WRITE_MASK |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_OP)) {
       uint32_t wm_depth_stencil_dw[GENX(3DSTATE_WM_DEPTH_STENCIL_length)];
 
       struct GENX(3DSTATE_WM_DEPTH_STENCIL wm_depth_stencil) = {
@@ -493,8 +490,7 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
                                       want_depth_pma_fix(cmd_buffer));
    }
 #else
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_BLEND_CONSTANTS)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_BLEND_CONSTANTS) {
       struct anv_state cc_state =
          anv_cmd_buffer_alloc_dynamic_state(cmd_buffer,
                                             GENX(COLOR_CALC_STATE_length) * 4,
@@ -513,16 +509,16 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       }
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_RENDER_TARGETS |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_COMPARE_MASK |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_WRITE_MASK |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_REFERENCE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
-                                          ANV_CMD_DIRTY_DYNAMIC_STENCIL_OP)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_RENDER_TARGETS |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_COMPARE_MASK |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_WRITE_MASK |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_REFERENCE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_TEST_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_WRITE_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_DEPTH_COMPARE_OP |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_TEST_ENABLE |
+                                      ANV_CMD_DIRTY_DYNAMIC_STENCIL_OP)) {
       uint32_t dwords[GENX(3DSTATE_WM_DEPTH_STENCIL_length)];
       struct GENX(3DSTATE_WM_DEPTH_STENCIL) wm_depth_stencil = {
          GENX(3DSTATE_WM_DEPTH_STENCIL_header),
@@ -565,9 +561,9 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
 #endif
 
 #if GFX_VER >= 12
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS |
-                                          ANV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE)) {
+   if(cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                     ANV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS |
+                                     ANV_CMD_DIRTY_DYNAMIC_DEPTH_BOUNDS_TEST_ENABLE)) {
       anv_batch_emit(&cmd_buffer->batch, GENX(3DSTATE_DEPTH_BOUNDS), db) {
          db.DepthBoundsTestEnable = d->depth_bounds_test_enable;
          db.DepthBoundsTestMinValue = d->depth_bounds.min;
@@ -576,8 +572,7 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
    }
 #endif
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_LINE_STIPPLE)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_LINE_STIPPLE) {
       anv_batch_emit(&cmd_buffer->batch, GENX(3DSTATE_LINE_STIPPLE), ls) {
          ls.LineStipplePattern = d->line_stipple.pattern;
          ls.LineStippleInverseRepeatCount =
@@ -586,9 +581,9 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
       }
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_INDEX_BUFFER |
-                                          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_INDEX_BUFFER |
+                                      ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE)) {
       anv_batch_emit(&cmd_buffer->batch, GENX(3DSTATE_VF), vf) {
 #if GFX_VERx10 >= 125
          vf.GeometryDistributionEnable = true;
@@ -599,8 +594,8 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
    }
 
 #if GFX_VERx10 >= 125
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE)) {
+   if (cmd_buffer->state.gfx.dirty & (ANV_CMD_DIRTY_PIPELINE |
+                                      ANV_CMD_DIRTY_DYNAMIC_PRIMITIVE_RESTART_ENABLE)) {
       anv_batch_emit(&cmd_buffer->batch, GENX(3DSTATE_VFG), vfg) {
          /* If 3DSTATE_TE: TE Enable == 1 then RR_STRICT else RR_FREE*/
          vfg.DistributionMode =
@@ -629,16 +624,14 @@ genX(cmd_buffer_flush_dynamic_state)(struct anv_cmd_buffer *cmd_buffer)
    }
 #endif
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_SAMPLE_LOCATIONS)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_SAMPLE_LOCATIONS) {
       genX(emit_sample_pattern)(&cmd_buffer->batch,
                                 cmd_buffer->state.gfx.dynamic.sample_locations.samples,
                                 cmd_buffer->state.gfx.dynamic.sample_locations.locations);
    }
 
-   if (anv_cmd_buffer_needs_dynamic_state(cmd_buffer,
-                                          ANV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_STATE |
-                                          ANV_CMD_DIRTY_DYNAMIC_LOGIC_OP)) {
+   if (cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_STATE ||
+       cmd_buffer->state.gfx.dirty & ANV_CMD_DIRTY_DYNAMIC_LOGIC_OP) {
       const uint8_t color_writes = cmd_buffer->state.gfx.dynamic.color_writes;
       /* 3DSTATE_WM in the hope we can avoid spawning fragment shaders
        * threads.
-- 
2.35.3

