From 29210dad8bf6d275ac4c1127aa27028055a73e7d Mon Sep 17 00:00:00 2001
From: gituser <nore@nop.np>
Date: Sat, 12 Mar 2022 16:40:41 +0100
Subject: [PATCH] Revert "iris: Restore flagging of dirty bindings in
 binder_realloc"

This reverts commit 01442cf4d4ef3af2c55532fe56cb9872682fb30c.
---
 src/gallium/drivers/iris/iris_binder.c | 30 ++++++++++++++------------
 1 file changed, 16 insertions(+), 14 deletions(-)

diff --git a/src/gallium/drivers/iris/iris_binder.c b/src/gallium/drivers/iris/iris_binder.c
index d2ae1f9092d..66a1ecff734 100644
--- a/src/gallium/drivers/iris/iris_binder.c
+++ b/src/gallium/drivers/iris/iris_binder.c
@@ -63,6 +63,7 @@ static void
 binder_realloc(struct iris_context *ice)
 {
    struct iris_screen *screen = (void *) ice->ctx.screen;
+   const struct intel_device_info *devinfo = &screen->devinfo;
    struct iris_bufmgr *bufmgr = screen->bufmgr;
    struct iris_binder *binder = &ice->state.binder;
 
@@ -76,20 +77,21 @@ binder_realloc(struct iris_context *ice)
    /* Avoid using offset 0 - tools consider it NULL. */
    binder->insert_point = binder->alignment;
 
-   /* Allocating a new binder requires changing Surface State Base Address,
-    * which also invalidates all our previous binding tables - each entry
-    * in those tables is an offset from the old base.
-    *
-    * We do this here so that iris_binder_reserve_3d correctly gets a new
-    * larger total_size when making the updated reservation.
-    *
-    * Gfx11+ simply updates the binding table pool address instead, which
-    * means the old binding table's contents are still valid.  Nevertheless,
-    * it still lives in the old BO, so we'd at least need to copy it to the
-    * new one.  Instead, we just flag it dirty and re-emit it anyway.
-    */
-   ice->state.dirty |= IRIS_DIRTY_RENDER_BUFFER;
-   ice->state.stage_dirty |= IRIS_ALL_STAGE_DIRTY_BINDINGS;
+   if (devinfo->ver < 11) {
+      /* Allocating a new binder requires changing Surface State Base Address,
+       * which also invalidates all our previous binding tables - each entry
+       * in those tables is an offset from the old base.
+       *
+       * We do this here so that iris_binder_reserve_3d correctly gets a new
+       * larger total_size when making the updated reservation.
+       *
+       * On Icelake and later, we just update the binding table pool address
+       * rather than moving surface state base address, so we no longer need
+       * to do any of this.
+       */
+      ice->state.dirty |= IRIS_DIRTY_RENDER_BUFFER;
+      ice->state.stage_dirty |= IRIS_ALL_STAGE_DIRTY_BINDINGS;
+   }
 }
 
 static uint32_t
-- 
2.35.1

